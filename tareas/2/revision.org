#+title: Revisi√≥n de la tarea #2
#+options: toc:nil num:nil

* Criterios de calificaci√≥n

- Toda entrega que muestre trabajo y se acerque al planteamiento,
  aunque no funcione, tiene asegurada una calificaci√≥n m√≠nima de 6
- Si replica exitosamente el primer ejemplo (s√≥lo tabla de
  resultados), 7.5
- Si presenta el esquema visual, 9
- Si desarrollan un algoritmo de colas m√∫ltiples (retroalimentaci√≥n
  multinivel/FB, ronda ego√≠sta/SRR), 9
- Si presenta el esquema visual y adem√°s desarrollan un algoritmo de
  colas m√∫ltiples, 10

* Revisi√≥n

** Benjam√≠n Anguiano y Omar Mart√≠n
- Documentaci√≥n :: [[./AnguianoBenjamin-martinOmar/Documentacion.txt][Documentacion.txt]]
- Archivos :: [[./AnguianoBenjamin-martinOmar/RoundRobin.java][RoundRobin.java]]
- Lenguaje de implementaci√≥n :: Java
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No
- Tabla de resultados :: No
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Implementan √∫nicamente uno de los algoritmos (RR con quantum fijo
    a 2). Doy por implementado el planteamiento base (FIFO, RR1, RR4,
    SPN) porque, si bien hicieron de menos, hicieron el mecanismo m√°s
    complicado.
  - No presentan (ni calculan) la tabla de ejecuci√≥n de cada vuelta
  - ¬°Ojo! Hicieron una entrega con fuentes en Java. ¬°Hay que proveer
    un =.gitignore= para ignorar a los =*.class=!
- Calificaci√≥n :: 7

** Emanuel Flores y Andrea Garc√≠a
- Documentaci√≥n :: [[./FloresEmanuel-GarciaAndrea/README.md][README.md]]
- Archivos :: [[./FloresEmanuel-GarciaAndrea/bf.py][bf.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: S√≠ (retroalimentaci√≥n multinivel)
- Comentarios ::
  - Al igual que en el caso anterior, implementaron √∫nicamente uno de
    los algoritmos ‚Äî Aunque el m√°s complicado de todos. Les doy
    parcial el punto de "replica exitosamente el primer ejemplo".
  - L√≠nea 108, mencionan como comentario =Duraci√≥n del quantum=, pero
    no asignan nada.
  - Manejan tres variables separadas, una para cada cola, y la funci√≥n
    =despachador()= (l√≠neas 31‚Äì42) est√° escrita espec√≠ficamente para
    este caso. Si tuvieran que ajustar el c√≥digo para manejar m√°s
    colas, se vuelve un dolorcito de cabeza... ¬°La respuesta est√° en
    parametrizar desde el principio! Si en la inicializaci√≥n de =FB=
    declaran un =self.numcolas=, y =self.colas = [ [] for i in
    range(numcolas) ]=, despachador podr√≠a simplificarse por:
    #+begin_src python
    def despachador(self):
      for cola in self.colas:
        if len(cola) >= 1:
          return cola
      return None
    #+end_src
    ¬øNo es m√°s f√°cil y bonito? üòâ
- Calificaci√≥n :: 8.5

** Andr√©s Gonz√°lez
- Documentaci√≥n :: [[./Gonz√°lezAndr√©s/README.md][README.md]]
- Archivos :: [[./Gonz√°lezAndr√©s/__init__.py][__init__.py]], [[./Gonz√°lezAndr√©s/algoritmos_planeacion.py][algoritmos_planeacion.py]], [[./Gonz√°lezAndr√©s/tarea2.py][tarea2.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: S√≠
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: S√≠ (Retroalimentaci√≥n multinivel)
- Comentarios ::
  - ¬°Muy buena implementaci√≥n!
  - Y muy bueno que tuvieras la curiosidad de jugar con la
    distribuci√≥n, como lo presentas en la documentaci√≥n. ¬øVes la
    flexibilidad que te da haber implementado un par de casos? El
    esfuerzo para hacer refinamientos baja dr√°sticamente.
  - Te sugiero un refinamiento: Tus funciones =test_*()= (una para
    cada mecanismo) se parecen mucho, /much√≠simo/ entre s√≠. ¬øTe has
    metido a hacer /programaci√≥n funcional/? Si hicieras una
    abstracci√≥n, en que tuvieras una √∫nica funci√≥n =test()=, y que
    recibiera como uno de sus par√°metros a /una funci√≥n/, podr√≠as
    reducir en mucho las l√≠neas de c√≥digo repetido en tu programa.
- Calificaci√≥n :: 10

** Jos√© Gonz√°lez y Alejandro Peralta
- Documentaci√≥n :: [[./GonzalezPastor-PeraltaEspinosa/algoritmos.pdf][algoritmos.pdf]]
- Archivos :: [[./GonzalezPastor-PeraltaEspinosa/main.cpp][main.cpp]]
- Lenguaje de implementaci√≥n :: C++
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No
- Tabla de resultados :: Parcial
- Esquema visual :: No
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - ¬øPara qu√© incluir el c√≥digo copiado como un PDF? No, eso no es
    documentaci√≥n ‚ò∫
  - ¬øPor qu√© √∫nicamente tres procesos? Adem√°s, todos llegan en
    =t=0=... Eso es un poquito aburrido ‚òπ
  - Desarrollaron FCFS y RR. ¬°Les resultaba trivial agregar SPN! (la
    diferencia con FCFS es √∫nicamente hacer una comparaci√≥n al momento
    de planificar).
  - Reportan √∫nicamente los valores resultantes para T y E, no para P
    o R (que ser√≠an triviales de obtener, ¬°y mucho m√°s √∫tiles!)
  - La funci√≥n =quantum()= (l√≠neas 41 a 51) me dej√≥ rasc√°ndome la
    cabeza. Para RR, ¬øel quantum lo definen como el promedio
    aproximado de duraci√≥n de los procesos? ¬øPor qu√© tan largo? ¬øqu√©
    efecto creen que este quantum tenga en un algoritmo como RR?
- Calificaci√≥n :: 7

** Luis L√≥pez
- Documentaci√≥n :: [[./LopezLuis/Tarea2.txt][Tarea2.txt]]
- Archivos :: [[./LopezLuis/Algoritmos.java][Algoritmos.java]], [[./LopezLuis/Inicio.java][Inicio.java]]
- Lenguaje de implementaci√≥n :: Java
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: Parcial (implementados, no todos
     funcionales)
- Tabla de resultados :: Parcial (s√≥lo para FCFS)
- Esquema visual :: Parcial (s√≥lo para RR)
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - ¬°Epa! ¬°Un poquito de parrafeo por favor! Escribir documentaci√≥n es
    parte important√≠sima de la formaci√≥n profesional. Y escribir
    documentaci√≥n no es √∫nicamente volcar palabras a texto ‚Äî Si no
    separas tus ideas en frases y p√°rrafos, resulta casi imposible
    leerlas.

    Sigo juntando valor para enfrentarme a tu documentaci√≥n ;-)
    - Ortograf√≠a (incluyendo acentuaci√≥n)
  - Comprendo la frustraci√≥n que describes, y no lo tomo como carencia
    tuya, sino que de la Facultad. Me parece que el problema principal
    es que no has aprendido a hacer la abstracci√≥n que requiere la
    soluci√≥n de problemas mediante la programaci√≥n. Te sugiero que, a
    modo de pr√°ctica, te pongas como objetivo implementar como un
    programa /todos/ los procedimientos que te cueste trabajo
    comprender, de esta materia o de cualquier otra. As√≠ vas a ir
    dominando debilidades como lo que describes en tu texto.
    - Importante: Lee c√≥digo de terceros. Vas a ir aprendiendo
      cuestiones de estilo. Tu c√≥digo es dif√≠cil de leer (porque le
      faltan comentarios, est√° indentado inconsistentemente, tiene
      mucha repetici√≥n...) y seguro se beneficiar√≠a de ello.
- Calificaci√≥n :: 7

** C√©sar Lugo
- Documentaci√≥n :: /No entregada/
- Archivos :: [[./LugoCesar/Tarea2.py][Tarea2.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No (falta SPN)
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - ¬°Disculpas por no incluirlo a tiempo en la revisi√≥n! ‚òπ
  - Las funciones que implementan los tres mecanismos que implementas
    (=FCFS()=, =RR1()= y =RR4()=) tienen mucha repetici√≥n. Podr√≠as
    separar en una sola funci√≥n, me parece, toda la l√≥gica a excepci√≥n
    del ciclo interno (el bloque =for i in range(l)= para FCFS y
    =while any(time !=0 for time in t)= para las RR), lo que har√≠a m√°s
    legible y mantenible tu c√≥digo
- Calificaci√≥n :: 9

** C√©sar Mart√≠nez y Lisset Noriega
- Documentaci√≥n :: /No entregada/
- Archivos :: [[./MartinezCesar-NoriegaLisset/FCFS.py][FCFS.py]], [[./MartinezCesar-NoriegaLisset/PlanifProcesos.py][PlanifProcesos.py]], [[./MartinezCesar-NoriegaLisset/Proceso.py][Proceso.py]], [[./MartinezCesar-NoriegaLisset/RoundRobin.py][RoundRobin.py]], [[./MartinezCesar-NoriegaLisset/SPN.py][SPN.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: S√≠
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Cuando Python se encuentra con programas que incluyen m√∫ltiples
    archivos fuente, los deja pre-compilados en el directorio
    =__pycache__=. ¬°Recuerden agregar dicho directorio a su =.gitignore=!
  - ¬°Buena implementaci√≥n y f√°cil de leer!
- Calificaci√≥n :: 9

** N√©stor Mart√≠nez
- Documentaci√≥n :: [[./MartinezNestor/README.md][README.md]]
- Archivos ::  [[./MartinezNestor/fcfs.py][fcfs.py]], [[./MartinezNestor/foundations.py][foundations.py]], [[./MartinezNestor/main.py][main.py]], [[./MartinezNestor/rr1.py][rr1.py]], [[./MartinezNestor/rr4.py][rr4.py]],
              [[./MartinezNestor/spn.py][spn.py]], [[./MartinezNestor/test.py][test.py]], [[./MartinezNestor/images/fcs_table.png][fcs_table.png]], [[./MartinezNestor/images/results.png][results.png]], [[./MartinezNestor/images/rr1.png][rr1.png]],
              [[./MartinezNestor/images/rr4.png][rr1_table.png]], [[./MartinezNestor/images/spn.png][rr4.png]], [[./MartinezNestor/images/rr1_table.png][spn.png]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: S√≠
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Buena implementaci√≥n. ¬°Muy buen uso de las estructuras que te
    provee =Foundation()=! Te ayudan a que el c√≥digo sea mucho m√°s
    claro
    - Aunque me hizo esperar un poco m√°s en cuesti√≥n de estilo. Hay
      mucha repetici√≥n de c√≥digo; particularmente RR1 y RR4, podr√≠an
      ser dos implementaciones muy cercanas, parametrizadas.
- Calificaci√≥n :: 9

** Luis Mata
- Documentaci√≥n :: /No entregada/
- Archivos :: [[./MataLuis/alea.py][alea.py]], [[./MataLuis/fifo.py][fifo.py]], [[./MataLuis/main.py][main.py]], [[./MataLuis/rond.py][rond.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No (falta SPN)
- Tabla de resultados :: S√≠
- Esquema visual :: No
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - No implementas SPN (que, al ser cooperativo, es /muy/
    simple... ¬°Apenas un FCFS con una comparaci√≥n m√°s!)
  - Para los valores P y R de las tablas, ser√≠a mucho m√°s adecuado
    utilizar aritm√©tica de punto flotante (no entera). En Python, para
    convertir un entero en flotante basta con multiplicarlo por =1.0=,
    o usar la funci√≥n =float()=: =float(5)= te da =5.0=.
- Calificaci√≥n :: 7

** Max Serrano
- Documentaci√≥n :: /No entregada/
- Archivos :: [[./MaxSerrano/t2.py][t2.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No
- Tabla de resultados :: No
- Esquema visual :: No
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - √önicamente implementas FIFO, y no funciona ‚òπ
  - Sin documentaci√≥n ni comentarios... Ni c√≥mo ayudarte ‚òπ
- Calificaci√≥n :: 6

** Luis Moreno y √Ångel Ram√≠rez
- Documentaci√≥n :: [[./MorenoLuis-RamirezAngel/Tarea2SistOp.pdf][Tarea2SistOp.pdf]]
- Archivos :: [[./MorenoLuis-RamirezAngel/Tarea2SistOp.c][Tarea2SistOp.c]]
- Lenguaje de implementaci√≥n :: C
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: S√≠
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Agradezco que lo documentaran ‚Äî La funci√≥n =time()= es provista en
    Linux por =time.h=.
  - Buena implementaci√≥n, bastante f√°cil de leer. Los comentarios
    ayudan a la comprensi√≥n.
  - al igual que a otros compa√±eros, les comento: A veces suena m√°s
    dif√≠cil planificar hacer las cosas /bonito/... Pero si se hubieran
    ahorrado la repetici√≥n de c√≥digo, el c√≥digo les habr√≠a resultado
    probablemente m√°s f√°cil, y seguramente m√°s mantenible (y, claro,
    m√°s legible).
- Calificaci√≥n :: 9

** Ricardo Mu√±oz y Sa√∫l Gabino
- Documentaci√≥n :: /No entregada/
- Archivos :: [[./Mu%C3%B1ozRicardo-GabinoSaul/round_robin/roundrobin.py][roundrobin.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No (s√≥lo RR)
- Tabla de resultados :: No
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Implementaron correctamente RR parametrizable, pero no incluyeron
    a ning√∫n otro algoritmo
  - Tuve que meterme a hacerle cirug√≠a al programa para que
    funcionara. Sin documentaci√≥n, sin instrucciones, esperando
    entrada de teclado... Y con un error de datos (tuve que comentar
    las l√≠neas 47 y 48 para que funcionara.
- Calificaci√≥n :: 7.5

** Jorge Ramos y Brian Espinoza
- Documentaci√≥n :: [[./RamosJorge-EspinozaBrian/readme.md][readme.md]]
- Archivos :: [[./RamosJorge-EspinozaBrian/tarea2.py][tarea2.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No (falta SPN)
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Los nombres que usan para las variables (p.ej. =t, L, i, CC= en
    =RoundRobin()=) dificultan poder entender y comentar acerca del
    programa ‚òπ
  - ¬°La implementaci√≥n de SPN deber√≠a ser trivial una vez que tienen
    FCFS lista!
- Calificaci√≥n :: 8.5

** Cristian Romero y Ulysses L√≥pez
- Documentaci√≥n :: [[./RomeroCristian_LopezUlysses/README.md][README.md]]
- Archivos :: [[./RomeroCristian_LopezUlysses/main.py][main.py]], [[./RomeroCristian_LopezUlysses/procesos/Fcfs.py][Fcfs.py]], [[./RomeroCristian_LopezUlysses/procesos/Planificar.py][Planificar.py]], [[./RomeroCristian_LopezUlysses/procesos/Proceso.py][Proceso.py]], [[./RomeroCristian_LopezUlysses/procesos/RRobin.py][RRobin.py]], [[./RomeroCristian_LopezUlysses/procesos/Spn.py][Spn.py]]
- Lenguaje de implementaci√≥n :: Python
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: S√≠
- Tabla de resultados :: S√≠
- Esquema visual :: S√≠
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - ¬°Buena presentaci√≥n! :-]
  - El programa muestra resultados un poco confusos por no saber como
    manejar el "no hay nada que hacer". Dado que aleatorizan la
    llegada, para evaluar las ejecuciones agregu√© esta l√≠nea en
    =main.py=, l√≠nea 12, forzando a que √©ste comience en cero:
    #+begin_src python
    procesos.append(Proceso([70,600], [0,0]))
    #+end_src
  - A√∫n as√≠, sigue habiendo algunos resultados de la ejecuci√≥n que no
    comprendo:
    #+begin_src text
      Round Robin: T = 13.83 , E = 9.67 , P = 3.29
      |Z||J||W||Z||J||W||Z||W||Z||W||L||Z||W||L||U||Q||Z||W||L||U||Q||L||U||Q||U|| |

      Round Robin: T = 2.33 , E = 1.00 , P = 1.67
      |Z||J||W||Z||W|| || || || ||L|| || || ||U|| ||Q|| |
    #+end_src
    ¬øPor qu√© hay esos espacios a medio camino? Implementaron RR4
    multiplicando el total de tiempos ‚Äî ¬°Pero no hicieron lo mismo para
    considerar el tiempo de llegadas!
  - Recuerden que SPN es un algoritmo /cooperativo/, no
    apropiativo. Esto es, no puede tomar decisiones de planificaci√≥n
    durante el tiempo de ejecuci√≥n de alg√∫n proceso. El programa me
    muestra:
    #+begin_src text
      SPN: T = 7.83 , E = 3.67 , P = 1.65
      |Z||J||J||Z||Z||Z||Z||Z||W||L||L||L||L||U||U||Q||Q||Q||U||U||W||W||W||W||W|| |
    #+end_src
    =J= √∫nicamente deber√≠a planificarse cuando =Z= termine su ejecuci√≥n.
- Calificaci√≥n :: 8.5

** Ricardo Rosales
- Documentaci√≥n :: [[./RosalesRicardo/README.md][README.md]]
- Archivos ::  [[./RosalesRicardo/index.html][index.html]], [[./RosalesRicardo/js/index.js][index.js]]
- Lenguaje de implementaci√≥n :: Javascript
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No (s√≥lo FCFS)
- Tabla de resultados :: S√≠
- Esquema visual :: No
- Alg√∫n algoritmo de colas m√∫ltiples :: S√≠ (FB)
- Comentarios ::
  - ¬°Por fin algo nuevo! ‚ò∫ Me da gusto revisar la l√≥gica de alguien
    que tiene "callo" a implementar sus ideas desde un paradigma
    distinto ‚Äî Javascript, sacando HTML
  - Te sugiero separar la presentaci√≥n de la l√≥gica. En tu funci√≥n
    =generaTablaBase= generas una tabla HTML, con sus atributos de
    despliegue (CSS), y le vas dando el contenido. Tus programas
    resultar√°n mucho m√°s mantenibles si separas la parte de despliegue
    y est√©tica de la parte de funcionalidad.
    - En el caso espec√≠fico de HTML / Javascript / CSS, te sugiero el
      uso de clases, y la definici√≥n (aunque sea en l√≠nea) de un
      estilo CSS que aplique a todos los elementos, en vez de irles
      dando estilo al irlos creando
  - Tu implementaci√≥n de retroalimentaci√≥n multinivel es bastante
    rara, al considerar al elemento con /un tiempo de inicio menor/
    (=encuentraMenor()=) ‚Äî ¬°Esa informaci√≥n no deber√≠a ser relevante
    para este planificador!
    - No hay manejo de quantums, tiempo restante, ... ‚Äî Si bien veo
      que comenzaste a implementar retroalimentaci√≥n multinivel... Lo
      que tienes es otra cosa ‚òπ ¬°Revisa los conceptos!
- Calificaci√≥n :: 8

** Eric Sanabria
- Documentaci√≥n :: [[./SanabriaErik/Readme.md][Readme.md]]
- Archivos :: [[./SanabriaErik/fcfs.cpp][fcfs.cpp]], [[./SanabriaErik/fcfs.h][fcfs.h]], [[./SanabriaErik/main.cpp][main.cpp]], [[./SanabriaErik/proc.cpp][proc.cpp]], [[./SanabriaErik/proc.h][proc.h]], [[./SanabriaErik/roundrobin.cpp][roundrobin.cpp]], [[./SanabriaErik/roundrobin.h][roundrobin.h]]
- Lenguaje de implementaci√≥n :: C++
- Se acerca al planteamiento :: S√≠
- Algoritmos base completos :: No (falta SPN)
- Tabla de resultados :: S√≠ (FCFS)
- Esquema visual :: No
- Alg√∫n algoritmo de colas m√∫ltiples :: No
- Comentarios ::
  - Respecto a tu documentaci√≥n: Te sugiero distinguir
    /requerimientos/ (no funciona sin eso) de /entorno de
    desarrollo/. Para el programa que presentas, nada te requiere ni
    una versi√≥n espec√≠fica de Linux, ni un tipo espec√≠fico de
    procesador ‚Äî Esos no son /requerimientos/.
    - Eclipse... podr√≠a ser, porque requiere picarle un poquito
      compilarlo /a pelo/ desde l√≠nea de comando con gcc ;-)
  - Hay alguna falla l√≥gica en tu implementaci√≥n de Round Robin:
    Despu√©s de ejecutar un quantum, sigue marcando el mismo tiempo
    pendiente.
    #+begin_src text
      (...)
      a: 4 m_num_proc: 4 size: 9 f: 3
      P0procesando por 3 segundos... de un tiempo requerido: 11

      A P0 le faltan: 3 segundos y hemos perdido: 

      a: 5 m_num_proc: 4 size: 10 f: 3
      P0procesando por 3 segundos... de un tiempo requerido: 11

      A P0 le faltan: 3 segundos y hemos perdido: 

      a: 6 m_num_proc: 4 size: 11 f: 3
      P0procesando por 3 segundos... de un tiempo requerido: 11

      A P0 le faltan: 3 segundos y hemos perdido: 

      a: 7 m_num_proc: 4 size: 12 f: 3
      P0procesando por 3 segundos... de un tiempo requerido: 11

      A P0 le faltan: 3 segundos y hemos perdido: 
    #+end_src
- Calificaci√≥n :: 7
